package searchindex

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"net/http"

	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/Azure/go-autorest/tracing"
	"github.com/gofrs/uuid"
)

// DocumentsClient is the client that can be used to query an index and upload, merge, or delete documents.
type DocumentsClient struct {
	BaseClient
}

// NewDocumentsClient creates an instance of the DocumentsClient client.
func NewDocumentsClient(searchServiceName string, indexName string) DocumentsClient {
	return DocumentsClient{New(searchServiceName, indexName)}
}

// AutocompleteGet autocompletes incomplete query terms based on input text and matching terms in the index.
// Parameters:
// searchText - the incomplete term which should be auto-completed.
// suggesterName - the name of the suggester as specified in the suggesters collection that's part of the index
// definition.
// clientRequestID - the tracking ID sent with the request to help with debugging.
// autocompleteMode - specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms' to get
// shingles and 'oneTermWithContext' to use the current context while producing auto-completed terms.
// filter - an OData expression that filters the documents used to produce completed terms for the Autocomplete
// result.
// useFuzzyMatching - a value indicating whether to use fuzzy matching for the autocomplete query. Default is
// false. When set to true, the query will find terms even if there's a substituted or missing character in the
// search text. While this provides a better experience in some scenarios, it comes at a performance cost as
// fuzzy autocomplete queries are slower and consume more resources.
// highlightPostTag - a string tag that is appended to hit highlights. Must be set with highlightPreTag. If
// omitted, hit highlighting is disabled.
// highlightPreTag - a string tag that is prepended to hit highlights. Must be set with highlightPostTag. If
// omitted, hit highlighting is disabled.
// minimumCoverage - a number between 0 and 100 indicating the percentage of the index that must be covered by
// an autocomplete query in order for the query to be reported as a success. This parameter can be useful for
// ensuring search availability even for services with only one replica. The default is 80.
// searchFields - the list of field names to consider when querying for auto-completed terms. Target fields
// must be included in the specified suggester.
// top - the number of auto-completed terms to retrieve. This must be a value between 1 and 100. The default is
// 5.
func (client DocumentsClient) AutocompleteGet(ctx context.Context, searchText string, suggesterName string, clientRequestID *uuid.UUID, autocompleteMode AutocompleteMode, filter string, useFuzzyMatching *bool, highlightPostTag string, highlightPreTag string, minimumCoverage *float64, searchFields []string, top *int32) (result AutocompleteResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DocumentsClient.AutocompleteGet")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.AutocompleteGetPreparer(ctx, searchText, suggesterName, clientRequestID, autocompleteMode, filter, useFuzzyMatching, highlightPostTag, highlightPreTag, minimumCoverage, searchFields, top)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "AutocompleteGet", nil, "Failure preparing request")
		return
	}

	resp, err := client.AutocompleteGetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "AutocompleteGet", resp, "Failure sending request")
		return
	}

	result, err = client.AutocompleteGetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "AutocompleteGet", resp, "Failure responding to request")
		return
	}

	return
}

// AutocompleteGetPreparer prepares the AutocompleteGet request.
func (client DocumentsClient) AutocompleteGetPreparer(ctx context.Context, searchText string, suggesterName string, clientRequestID *uuid.UUID, autocompleteMode AutocompleteMode, filter string, useFuzzyMatching *bool, highlightPostTag string, highlightPreTag string, minimumCoverage *float64, searchFields []string, top *int32) (*http.Request, error) {
	urlParameters := map[string]interface{}{

		"indexName":         client.IndexName,
		"searchDnsSuffix":   client.SearchDNSSuffix,
		"searchServiceName": client.SearchServiceName,
	}

	const APIVersion = "2019-05-06"
	queryParameters := map[string]interface{}{
		"api-version":   APIVersion,
		"search":        autorest.Encode("query", searchText),
		"suggesterName": autorest.Encode("query", suggesterName),
	}
	if len(string(autocompleteMode)) > 0 {
		queryParameters["autocompleteMode"] = autorest.Encode("query", autocompleteMode)
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if useFuzzyMatching != nil {
		queryParameters["fuzzy"] = autorest.Encode("query", *useFuzzyMatching)
	}
	if len(highlightPostTag) > 0 {
		queryParameters["highlightPostTag"] = autorest.Encode("query", highlightPostTag)
	}
	if len(highlightPreTag) > 0 {
		queryParameters["highlightPreTag"] = autorest.Encode("query", highlightPreTag)
	}
	if minimumCoverage != nil {
		queryParameters["minimumCoverage"] = autorest.Encode("query", *minimumCoverage)
	}
	if searchFields != nil && len(searchFields) > 0 {
		queryParameters["searchFields"] = autorest.Encode("query", searchFields, ",")
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{searchServiceName}.{searchDnsSuffix}/indexes('{indexName}')", urlParameters),
		autorest.WithPath("/docs/search.autocomplete"),
		autorest.WithQueryParameters(queryParameters))
	if clientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// AutocompleteGetSender sends the AutocompleteGet request. The method will close the
// http.Response Body if it receives an error.
func (client DocumentsClient) AutocompleteGetSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// AutocompleteGetResponder handles the response to the AutocompleteGet request. The method always
// closes the http.Response Body.
func (client DocumentsClient) AutocompleteGetResponder(resp *http.Response) (result AutocompleteResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// AutocompletePost autocompletes incomplete query terms based on input text and matching terms in the index.
// Parameters:
// autocompleteRequest - the definition of the Autocomplete request.
// clientRequestID - the tracking ID sent with the request to help with debugging.
func (client DocumentsClient) AutocompletePost(ctx context.Context, autocompleteRequest AutocompleteRequest, clientRequestID *uuid.UUID) (result AutocompleteResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DocumentsClient.AutocompletePost")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.AutocompletePostPreparer(ctx, autocompleteRequest, clientRequestID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "AutocompletePost", nil, "Failure preparing request")
		return
	}

	resp, err := client.AutocompletePostSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "AutocompletePost", resp, "Failure sending request")
		return
	}

	result, err = client.AutocompletePostResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "AutocompletePost", resp, "Failure responding to request")
		return
	}

	return
}

// AutocompletePostPreparer prepares the AutocompletePost request.
func (client DocumentsClient) AutocompletePostPreparer(ctx context.Context, autocompleteRequest AutocompleteRequest, clientRequestID *uuid.UUID) (*http.Request, error) {
	urlParameters := map[string]interface{}{

		"indexName":         client.IndexName,
		"searchDnsSuffix":   client.SearchDNSSuffix,
		"searchServiceName": client.SearchServiceName,
	}

	const APIVersion = "2019-05-06"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithCustomBaseURL("https://{searchServiceName}.{searchDnsSuffix}/indexes('{indexName}')", urlParameters),
		autorest.WithPath("/docs/search.post.autocomplete"),
		autorest.WithJSON(autocompleteRequest),
		autorest.WithQueryParameters(queryParameters))
	if clientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// AutocompletePostSender sends the AutocompletePost request. The method will close the
// http.Response Body if it receives an error.
func (client DocumentsClient) AutocompletePostSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// AutocompletePostResponder handles the response to the AutocompletePost request. The method always
// closes the http.Response Body.
func (client DocumentsClient) AutocompletePostResponder(resp *http.Response) (result AutocompleteResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Count queries the number of documents in the index.
// Parameters:
// clientRequestID - the tracking ID sent with the request to help with debugging.
func (client DocumentsClient) Count(ctx context.Context, clientRequestID *uuid.UUID) (result Int64, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DocumentsClient.Count")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CountPreparer(ctx, clientRequestID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "Count", nil, "Failure preparing request")
		return
	}

	resp, err := client.CountSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "Count", resp, "Failure sending request")
		return
	}

	result, err = client.CountResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "Count", resp, "Failure responding to request")
		return
	}

	return
}

// CountPreparer prepares the Count request.
func (client DocumentsClient) CountPreparer(ctx context.Context, clientRequestID *uuid.UUID) (*http.Request, error) {
	urlParameters := map[string]interface{}{

		"indexName":         client.IndexName,
		"searchDnsSuffix":   client.SearchDNSSuffix,
		"searchServiceName": client.SearchServiceName,
	}

	const APIVersion = "2019-05-06"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{searchServiceName}.{searchDnsSuffix}/indexes('{indexName}')", urlParameters),
		autorest.WithPath("/docs/$count"),
		autorest.WithQueryParameters(queryParameters))
	if clientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CountSender sends the Count request. The method will close the
// http.Response Body if it receives an error.
func (client DocumentsClient) CountSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CountResponder handles the response to the Count request. The method always
// closes the http.Response Body.
func (client DocumentsClient) CountResponder(resp *http.Response) (result Int64, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Get retrieves a document from the index.
// Parameters:
// key - the key of the document to retrieve.
// selectedFields - list of field names to retrieve for the document; Any field not retrieved will be missing
// from the returned document.
// clientRequestID - the tracking ID sent with the request to help with debugging.
func (client DocumentsClient) Get(ctx context.Context, key string, selectedFields []string, clientRequestID *uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DocumentsClient.Get")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetPreparer(ctx, key, selectedFields, clientRequestID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "Get", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "Get", resp, "Failure sending request")
		return
	}

	result, err = client.GetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "Get", resp, "Failure responding to request")
		return
	}

	return
}

// GetPreparer prepares the Get request.
func (client DocumentsClient) GetPreparer(ctx context.Context, key string, selectedFields []string, clientRequestID *uuid.UUID) (*http.Request, error) {
	urlParameters := map[string]interface{}{

		"indexName":         client.IndexName,
		"searchDnsSuffix":   client.SearchDNSSuffix,
		"searchServiceName": client.SearchServiceName,
	}

	pathParameters := map[string]interface{}{
		"key": autorest.Encode("path", key),
	}

	const APIVersion = "2019-05-06"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if selectedFields != nil && len(selectedFields) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectedFields, ",")
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{searchServiceName}.{searchDnsSuffix}/indexes('{indexName}')", urlParameters),
		autorest.WithPathParameters("/docs('{key}')", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if clientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSender sends the Get request. The method will close the
// http.Response Body if it receives an error.
func (client DocumentsClient) GetSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetResponder handles the response to the Get request. The method always
// closes the http.Response Body.
func (client DocumentsClient) GetResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Index sends a batch of document write actions to the index.
// Parameters:
// batch - the batch of index actions.
// clientRequestID - the tracking ID sent with the request to help with debugging.
func (client DocumentsClient) Index(ctx context.Context, batch IndexBatch, clientRequestID *uuid.UUID) (result IndexDocumentsResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DocumentsClient.Index")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: batch,
			Constraints: []validation.Constraint{{Target: "batch.Actions", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("searchindex.DocumentsClient", "Index", err.Error())
	}

	req, err := client.IndexPreparer(ctx, batch, clientRequestID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "Index", nil, "Failure preparing request")
		return
	}

	resp, err := client.IndexSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "Index", resp, "Failure sending request")
		return
	}

	result, err = client.IndexResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "Index", resp, "Failure responding to request")
		return
	}

	return
}

// IndexPreparer prepares the Index request.
func (client DocumentsClient) IndexPreparer(ctx context.Context, batch IndexBatch, clientRequestID *uuid.UUID) (*http.Request, error) {
	urlParameters := map[string]interface{}{

		"indexName":         client.IndexName,
		"searchDnsSuffix":   client.SearchDNSSuffix,
		"searchServiceName": client.SearchServiceName,
	}

	const APIVersion = "2019-05-06"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithCustomBaseURL("https://{searchServiceName}.{searchDnsSuffix}/indexes('{indexName}')", urlParameters),
		autorest.WithPath("/docs/search.index"),
		autorest.WithJSON(batch),
		autorest.WithQueryParameters(queryParameters))
	if clientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// IndexSender sends the Index request. The method will close the
// http.Response Body if it receives an error.
func (client DocumentsClient) IndexSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// IndexResponder handles the response to the Index request. The method always
// closes the http.Response Body.
func (client DocumentsClient) IndexResponder(resp *http.Response) (result IndexDocumentsResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusMultiStatus),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// SearchGet searches for documents in the index.
// Parameters:
// searchText - a full-text search query expression; Use "*" or omit this parameter to match all documents.
// includeTotalResultCount - a value that specifies whether to fetch the total count of results. Default is
// false. Setting this value to true may have a performance impact. Note that the count returned is an
// approximation.
// facets - the list of facet expressions to apply to the search query. Each facet expression contains a field
// name, optionally followed by a comma-separated list of name:value pairs.
// filter - the OData $filter expression to apply to the search query.
// highlightFields - the list of field names to use for hit highlights. Only searchable fields can be used for
// hit highlighting.
// highlightPostTag - a string tag that is appended to hit highlights. Must be set with highlightPreTag.
// Default is &lt;/em&gt;.
// highlightPreTag - a string tag that is prepended to hit highlights. Must be set with highlightPostTag.
// Default is &lt;em&gt;.
// minimumCoverage - a number between 0 and 100 indicating the percentage of the index that must be covered by
// a search query in order for the query to be reported as a success. This parameter can be useful for ensuring
// search availability even for services with only one replica. The default is 100.
// orderBy - the list of OData $orderby expressions by which to sort the results. Each expression can be either
// a field name or a call to either the geo.distance() or the search.score() functions. Each expression can be
// followed by asc to indicate ascending, and desc to indicate descending. The default is ascending order. Ties
// will be broken by the match scores of documents. If no OrderBy is specified, the default sort order is
// descending by document match score. There can be at most 32 $orderby clauses.
// queryType - a value that specifies the syntax of the search query. The default is 'simple'. Use 'full' if
// your query uses the Lucene query syntax.
// scoringParameters - the list of parameter values to be used in scoring functions (for example,
// referencePointParameter) using the format name-values. For example, if the scoring profile defines a
// function with a parameter called 'mylocation' the parameter string would be "mylocation--122.2,44.8"
// (without the quotes).
// scoringProfile - the name of a scoring profile to evaluate match scores for matching documents in order to
// sort the results.
// searchFields - the list of field names to which to scope the full-text search. When using fielded search
// (fieldName:searchExpression) in a full Lucene query, the field names of each fielded search expression take
// precedence over any field names listed in this parameter.
// searchMode - a value that specifies whether any or all of the search terms must be matched in order to count
// the document as a match.
// selectParameter - the list of fields to retrieve. If unspecified, all fields marked as retrievable in the
// schema are included.
// skip - the number of search results to skip. This value cannot be greater than 100,000. If you need to scan
// documents in sequence, but cannot use $skip due to this limitation, consider using $orderby on a
// totally-ordered key and $filter with a range query instead.
// top - the number of search results to retrieve. This can be used in conjunction with $skip to implement
// client-side paging of search results. If results are truncated due to server-side paging, the response will
// include a continuation token that can be used to issue another Search request for the next page of results.
// clientRequestID - the tracking ID sent with the request to help with debugging.
func (client DocumentsClient) SearchGet(ctx context.Context, searchText string, includeTotalResultCount *bool, facets []string, filter string, highlightFields []string, highlightPostTag string, highlightPreTag string, minimumCoverage *float64, orderBy []string, queryType QueryType, scoringParameters []string, scoringProfile string, searchFields []string, searchMode SearchMode, selectParameter []string, skip *int32, top *int32, clientRequestID *uuid.UUID) (result SearchDocumentsResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DocumentsClient.SearchGet")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.SearchGetPreparer(ctx, searchText, includeTotalResultCount, facets, filter, highlightFields, highlightPostTag, highlightPreTag, minimumCoverage, orderBy, queryType, scoringParameters, scoringProfile, searchFields, searchMode, selectParameter, skip, top, clientRequestID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "SearchGet", nil, "Failure preparing request")
		return
	}

	resp, err := client.SearchGetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "SearchGet", resp, "Failure sending request")
		return
	}

	result, err = client.SearchGetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "SearchGet", resp, "Failure responding to request")
		return
	}

	return
}

// SearchGetPreparer prepares the SearchGet request.
func (client DocumentsClient) SearchGetPreparer(ctx context.Context, searchText string, includeTotalResultCount *bool, facets []string, filter string, highlightFields []string, highlightPostTag string, highlightPreTag string, minimumCoverage *float64, orderBy []string, queryType QueryType, scoringParameters []string, scoringProfile string, searchFields []string, searchMode SearchMode, selectParameter []string, skip *int32, top *int32, clientRequestID *uuid.UUID) (*http.Request, error) {
	urlParameters := map[string]interface{}{

		"indexName":         client.IndexName,
		"searchDnsSuffix":   client.SearchDNSSuffix,
		"searchServiceName": client.SearchServiceName,
	}

	const APIVersion = "2019-05-06"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(searchText) > 0 {
		queryParameters["search"] = autorest.Encode("query", searchText)
	}
	if includeTotalResultCount != nil {
		queryParameters["$count"] = autorest.Encode("query", *includeTotalResultCount)
	}
	if facets != nil && len(facets) > 0 {
		queryParameters["facet"] = facets
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if highlightFields != nil && len(highlightFields) > 0 {
		queryParameters["highlight"] = autorest.Encode("query", highlightFields, ",")
	}
	if len(highlightPostTag) > 0 {
		queryParameters["highlightPostTag"] = autorest.Encode("query", highlightPostTag)
	}
	if len(highlightPreTag) > 0 {
		queryParameters["highlightPreTag"] = autorest.Encode("query", highlightPreTag)
	}
	if minimumCoverage != nil {
		queryParameters["minimumCoverage"] = autorest.Encode("query", *minimumCoverage)
	}
	if orderBy != nil && len(orderBy) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderBy, ",")
	}
	if len(string(queryType)) > 0 {
		queryParameters["queryType"] = autorest.Encode("query", queryType)
	}
	if scoringParameters != nil && len(scoringParameters) > 0 {
		queryParameters["scoringParameter"] = scoringParameters
	}
	if len(scoringProfile) > 0 {
		queryParameters["scoringProfile"] = autorest.Encode("query", scoringProfile)
	}
	if searchFields != nil && len(searchFields) > 0 {
		queryParameters["searchFields"] = autorest.Encode("query", searchFields, ",")
	}
	if len(string(searchMode)) > 0 {
		queryParameters["searchMode"] = autorest.Encode("query", searchMode)
	}
	if selectParameter != nil && len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter, ",")
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{searchServiceName}.{searchDnsSuffix}/indexes('{indexName}')", urlParameters),
		autorest.WithPath("/docs"),
		autorest.WithQueryParameters(queryParameters))
	if clientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SearchGetSender sends the SearchGet request. The method will close the
// http.Response Body if it receives an error.
func (client DocumentsClient) SearchGetSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// SearchGetResponder handles the response to the SearchGet request. The method always
// closes the http.Response Body.
func (client DocumentsClient) SearchGetResponder(resp *http.Response) (result SearchDocumentsResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// SearchPost searches for documents in the index.
// Parameters:
// searchRequest - the definition of the Search request.
// clientRequestID - the tracking ID sent with the request to help with debugging.
func (client DocumentsClient) SearchPost(ctx context.Context, searchRequest SearchRequest, clientRequestID *uuid.UUID) (result SearchDocumentsResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DocumentsClient.SearchPost")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.SearchPostPreparer(ctx, searchRequest, clientRequestID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "SearchPost", nil, "Failure preparing request")
		return
	}

	resp, err := client.SearchPostSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "SearchPost", resp, "Failure sending request")
		return
	}

	result, err = client.SearchPostResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "SearchPost", resp, "Failure responding to request")
		return
	}

	return
}

// SearchPostPreparer prepares the SearchPost request.
func (client DocumentsClient) SearchPostPreparer(ctx context.Context, searchRequest SearchRequest, clientRequestID *uuid.UUID) (*http.Request, error) {
	urlParameters := map[string]interface{}{

		"indexName":         client.IndexName,
		"searchDnsSuffix":   client.SearchDNSSuffix,
		"searchServiceName": client.SearchServiceName,
	}

	const APIVersion = "2019-05-06"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithCustomBaseURL("https://{searchServiceName}.{searchDnsSuffix}/indexes('{indexName}')", urlParameters),
		autorest.WithPath("/docs/search.post.search"),
		autorest.WithJSON(searchRequest),
		autorest.WithQueryParameters(queryParameters))
	if clientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SearchPostSender sends the SearchPost request. The method will close the
// http.Response Body if it receives an error.
func (client DocumentsClient) SearchPostSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// SearchPostResponder handles the response to the SearchPost request. The method always
// closes the http.Response Body.
func (client DocumentsClient) SearchPostResponder(resp *http.Response) (result SearchDocumentsResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// SuggestGet suggests documents in the index that match the given partial query text.
// Parameters:
// searchText - the search text to use to suggest documents. Must be at least 1 character, and no more than 100
// characters.
// suggesterName - the name of the suggester as specified in the suggesters collection that's part of the index
// definition.
// filter - an OData expression that filters the documents considered for suggestions.
// useFuzzyMatching - a value indicating whether to use fuzzy matching for the suggestions query. Default is
// false. When set to true, the query will find terms even if there's a substituted or missing character in the
// search text. While this provides a better experience in some scenarios, it comes at a performance cost as
// fuzzy suggestions queries are slower and consume more resources.
// highlightPostTag - a string tag that is appended to hit highlights. Must be set with highlightPreTag. If
// omitted, hit highlighting of suggestions is disabled.
// highlightPreTag - a string tag that is prepended to hit highlights. Must be set with highlightPostTag. If
// omitted, hit highlighting of suggestions is disabled.
// minimumCoverage - a number between 0 and 100 indicating the percentage of the index that must be covered by
// a suggestions query in order for the query to be reported as a success. This parameter can be useful for
// ensuring search availability even for services with only one replica. The default is 80.
// orderBy - the list of OData $orderby expressions by which to sort the results. Each expression can be either
// a field name or a call to either the geo.distance() or the search.score() functions. Each expression can be
// followed by asc to indicate ascending, or desc to indicate descending. The default is ascending order. Ties
// will be broken by the match scores of documents. If no $orderby is specified, the default sort order is
// descending by document match score. There can be at most 32 $orderby clauses.
// searchFields - the list of field names to search for the specified search text. Target fields must be
// included in the specified suggester.
// selectParameter - the list of fields to retrieve. If unspecified, only the key field will be included in the
// results.
// top - the number of suggestions to retrieve. The value must be a number between 1 and 100. The default is 5.
// clientRequestID - the tracking ID sent with the request to help with debugging.
func (client DocumentsClient) SuggestGet(ctx context.Context, searchText string, suggesterName string, filter string, useFuzzyMatching *bool, highlightPostTag string, highlightPreTag string, minimumCoverage *float64, orderBy []string, searchFields []string, selectParameter []string, top *int32, clientRequestID *uuid.UUID) (result SuggestDocumentsResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DocumentsClient.SuggestGet")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.SuggestGetPreparer(ctx, searchText, suggesterName, filter, useFuzzyMatching, highlightPostTag, highlightPreTag, minimumCoverage, orderBy, searchFields, selectParameter, top, clientRequestID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "SuggestGet", nil, "Failure preparing request")
		return
	}

	resp, err := client.SuggestGetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "SuggestGet", resp, "Failure sending request")
		return
	}

	result, err = client.SuggestGetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "SuggestGet", resp, "Failure responding to request")
		return
	}

	return
}

// SuggestGetPreparer prepares the SuggestGet request.
func (client DocumentsClient) SuggestGetPreparer(ctx context.Context, searchText string, suggesterName string, filter string, useFuzzyMatching *bool, highlightPostTag string, highlightPreTag string, minimumCoverage *float64, orderBy []string, searchFields []string, selectParameter []string, top *int32, clientRequestID *uuid.UUID) (*http.Request, error) {
	urlParameters := map[string]interface{}{

		"indexName":         client.IndexName,
		"searchDnsSuffix":   client.SearchDNSSuffix,
		"searchServiceName": client.SearchServiceName,
	}

	const APIVersion = "2019-05-06"
	queryParameters := map[string]interface{}{
		"api-version":   APIVersion,
		"search":        autorest.Encode("query", searchText),
		"suggesterName": autorest.Encode("query", suggesterName),
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if useFuzzyMatching != nil {
		queryParameters["fuzzy"] = autorest.Encode("query", *useFuzzyMatching)
	}
	if len(highlightPostTag) > 0 {
		queryParameters["highlightPostTag"] = autorest.Encode("query", highlightPostTag)
	}
	if len(highlightPreTag) > 0 {
		queryParameters["highlightPreTag"] = autorest.Encode("query", highlightPreTag)
	}
	if minimumCoverage != nil {
		queryParameters["minimumCoverage"] = autorest.Encode("query", *minimumCoverage)
	}
	if orderBy != nil && len(orderBy) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderBy, ",")
	}
	if searchFields != nil && len(searchFields) > 0 {
		queryParameters["searchFields"] = autorest.Encode("query", searchFields, ",")
	}
	if selectParameter != nil && len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter, ",")
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithCustomBaseURL("https://{searchServiceName}.{searchDnsSuffix}/indexes('{indexName}')", urlParameters),
		autorest.WithPath("/docs/search.suggest"),
		autorest.WithQueryParameters(queryParameters))
	if clientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SuggestGetSender sends the SuggestGet request. The method will close the
// http.Response Body if it receives an error.
func (client DocumentsClient) SuggestGetSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// SuggestGetResponder handles the response to the SuggestGet request. The method always
// closes the http.Response Body.
func (client DocumentsClient) SuggestGetResponder(resp *http.Response) (result SuggestDocumentsResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// SuggestPost suggests documents in the index that match the given partial query text.
// Parameters:
// suggestRequest - the Suggest request.
// clientRequestID - the tracking ID sent with the request to help with debugging.
func (client DocumentsClient) SuggestPost(ctx context.Context, suggestRequest SuggestRequest, clientRequestID *uuid.UUID) (result SuggestDocumentsResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DocumentsClient.SuggestPost")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.SuggestPostPreparer(ctx, suggestRequest, clientRequestID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "SuggestPost", nil, "Failure preparing request")
		return
	}

	resp, err := client.SuggestPostSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "SuggestPost", resp, "Failure sending request")
		return
	}

	result, err = client.SuggestPostResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "searchindex.DocumentsClient", "SuggestPost", resp, "Failure responding to request")
		return
	}

	return
}

// SuggestPostPreparer prepares the SuggestPost request.
func (client DocumentsClient) SuggestPostPreparer(ctx context.Context, suggestRequest SuggestRequest, clientRequestID *uuid.UUID) (*http.Request, error) {
	urlParameters := map[string]interface{}{

		"indexName":         client.IndexName,
		"searchDnsSuffix":   client.SearchDNSSuffix,
		"searchServiceName": client.SearchServiceName,
	}

	const APIVersion = "2019-05-06"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithCustomBaseURL("https://{searchServiceName}.{searchDnsSuffix}/indexes('{indexName}')", urlParameters),
		autorest.WithPath("/docs/search.post.suggest"),
		autorest.WithJSON(suggestRequest),
		autorest.WithQueryParameters(queryParameters))
	if clientRequestID != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SuggestPostSender sends the SuggestPost request. The method will close the
// http.Response Body if it receives an error.
func (client DocumentsClient) SuggestPostSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// SuggestPostResponder handles the response to the SuggestPost request. The method always
// closes the http.Response Body.
func (client DocumentsClient) SuggestPostResponder(resp *http.Response) (result SuggestDocumentsResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
